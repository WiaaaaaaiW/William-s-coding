
# Program Name: Jukebox.py
#
# Author(s): Jason Feng, Yuxin Liu, William Sun
#
# Date: 06/03/2025
#
# Description:
# This program allows users to create a music playlist by selecting songs from a database.
# The playlist is saved to a CSV file, and the songs are played automatically using their links.
#




import csv
import webbrowser, time
import os

# Stack class for implementing a stack data structure
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[-1]

    def isEmpty(self):
        return not bool(self.items)

    def size(self):
        return len(self.items)

# Queue class for implementing a queue data structure
class Queue():
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.insert(0, item)

    def dequeue(self):
        return self.items.pop()

    def isEmpty(self):
        return not bool(self.items)

    def size(self):
        return len(self.items)

# Load artist database from CSV file
artists = []
f = 'ArtistDB.csv'
fieldnames = ['name', 'artist', 'length', 'link']

# Create CSV file if it does not exist
if not os.path.exists(f):
    with open(f, 'w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()

# Read the artist database from CSV file
if os.path.exists(f):
    with open(f, 'r', newline='') as file:
        reader = csv.DictReader(file)
        artists = [row for row in reader]

# Function to display a menu and allow users to select a song by number
def present_menu(artists):
    while True:
        print("\nChoose a song by number:")
        for i, artist in enumerate(artists, 1):
            print(f"{i}. {artist['name']} by {artist['artist']}")

        try:
            selection = int(input("Enter the number of your selection (or 0 to quit): ").strip())
            if selection == 0:
                return "Quit"
            elif 1 <= selection <= len(artists):
                return artists[selection - 1]
            else:
                print("Invalid selection. Please enter a number from the list.")
        except ValueError:
            print("Invalid input. Please enter a number.")

# Function to create a playlist based on user selection
def playlists():
    playlist = []
    count = 0

    while True:
        if count < 3:  # Limit playlist to 3 songs
            selected_song = present_menu(artists)
            if selected_song == "Quit":
                break
            if selected_song:
                playlist.append(selected_song)
                count += 1
            else:
                print("No song selected.")
                return False
        else:
            break
    return playlist

# Function to save the playlist to a CSV file
def save_playlist_to_csv(playlist):
    if playlist:
        with open('PlayList.csv', 'w', newline='') as file:
            fieldnames = ['name', 'artist', 'length', 'link']
            writer = csv.DictWriter(file, fieldnames=fieldnames)
            writer.writeheader()

            # Ensure only valid fields are written to the CSV
            clean_playlist = [{k: v for k, v in song.items() if k in fieldnames} for song in playlist]
            writer.writerows(clean_playlist)
        print("Playlist saved to PlayList.csv")
    else:
        print("No playlist to save.")

# Main function to create and save a playlist
def main():
    final_playlist = playlists()
    save_playlist_to_csv(final_playlist)

if __name__ == "__main__":
    main()

# Initialize the queue for playing videos
q = Queue()

while True:
    if not os.path.exists('PlayList.csv'):
        print("Waiting for playlist...")
        time.sleep(15)
        continue
    else:
        with open('PlayList.csv', 'r', encoding='utf-8-sig') as file:
            reader = csv.DictReader(file)
            videos = [row for row in reader]

        for video in videos:
            if video and 'link' in video:
                q.enqueue(video)

    print(f"Total videos in queue: {q.size()}")

    # Function to convert time format (MM:SS or H:MM:SS) to total seconds
    def convert_to_seconds(t_str):
        t_parts = t_str.split(":")
        if len(t_parts) == 2:
            minutes = int(t_parts[0])
            seconds = int(t_parts[1])
            total_s = (minutes * 60) + seconds
            return total_s
        elif len(t_parts) == 3:
            hours = int(t_parts[0])
            minutes = int(t_parts[1])
            seconds = int(t_parts[2])
            total_s = (hours * 3600) + (minutes * 60) + seconds
        else:
            return 0
        return total_s

    # Process the queue and play videos
    while not q.isEmpty():
        current_v = q.dequeue()
        v_link = current_v['link']
        v_name = current_v['name']
        v_length_str = current_v.get('length', 0)
        v_length = convert_to_seconds(v_length_str) if ":" in v_length_str else int(v_length_str)

        print(f'{v_name} is now playing.')
        webbrowser.open(v_link)

        if v_length > 0:
            print(f'Waiting for {v_length} seconds...')
            time.sleep(v_length)
        else:
            print("No song found. Waiting 5 minutes (default).")
            time.sleep(300)

        print("Moving to the next video...\n")

